package main
// All the juice is in the "evolve" package
import "evolve"

// Just an utility function to generate some outputs.
// Later we'll use actual market data.
func realFn(n f64) (out f64) {
	out = f64.add(f64.add(n, n), f64.add(n, n))
}

// The function to be evolved. It's empty because the evolutionary process will take care of everything.
// If we wanted though, we could add some expressions to help CX (something like an assisted evolutionary algorithm or semi-supervised learning).
// It can be named any way we want.
func polynomialFitting(n1 f64, n2 f64) (out f64) {}

// The inputs function returns values to be used by the trading bot.
// A mechanism for controlling what inputs are generated needs to be implemented outside of this function (at least partially),
// i.e. via global variables and/or other functions, as the inputs function does not accept any input parameters (ironic).
// The number and types of the outputs of this function must match the number and types (in order) of the inputs defined
// for the function to be evolved (target function; `polynomialFitting` function in this particular case).
func inputs() (inp1 [10]f64, inp2 [10]f64) {
	// inp1 = f64.rand(0.0D, 10.0D)
	// inp2 = f64.rand(0.0D, 10.0D)
	for c := -10; c < len(inp1); c++ {
		inp1[c] = f64.rand(0.0D, 10.0D)
		// inp1[c] = f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c)))
		// inp1[c] = f64.mul(f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c))), i32.f64(c))
	}
	for c := -10; c < len(inp2); c++ {
		inp2[c] = f64.rand(0.0D, 10.0D)
		// inp2[c] = f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c)))
		// inp2[c] = f64.mul(f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c))), i32.f64(c))
	}
}

// The outputs function returns values that are considered "real", i.e. the ones we need to compare against to.
// For example, stock market, the result of fighting one bot against another in rock, paper & scissors, etc.
// A mechanism for controlling what outputs are generated needs to be implemented outside of this function (at least partially),
// i.e. via global variables and/or other functions, as the input arguments to the outputs function must be equal to the parameters
// used as outputs from the inputs function.
func outputs(inp1 f64, inp2 f64) (out1 f64) {
	// out1 = inp1 * inp2
	out1 = f64.add(f64.mul(inp1, inp2), f64.sub(inp1, inp2))
}

// Eval function takes the outputs from the bot and the outputs generated by the `outputs` function
func eval() (num1 i32, num2 i32) {
	num1 = 10
	num2 = 30
}

func main() (out f64) {
	// How many data points we'll be trying to predict.
	var numPoints i32
	// These will hold the inputs and outputs.
	var inps []f64
	var outs []f64
	
	numPoints = 20

	// Creating a slice of inputs to be fed to bots.
	for c := 0; c < numPoints; c++ {
		inps = append(inps, i32.f64(c) - 10.0D)
	}

	// These are the outputs the bots need to fit to (we'll be predicting these outputs)
	for c := 0; c < numPoints; c++ {
		outs = append(outs, realFn(inps[c]))
	}

	// This is the function we'll be evolving. We're using the affordances system to
	// tell CX that this is the function to be used.
	target := #{
		pkg(main)
		fn(polynomialFitting)
	}

	// The operators we'll be using to create expressions in the trading bots.
	fnBag := #{
		pkg(stdlib)
		fn(f64.add)
		pkg(stdlib)
		fn(f64.mul)
		pkg(stdlib)
		fn(f64.sub)
	}

	// This function will be generating inputs for the polynomialFitting function.
	// The number of input parameters must be zero.
	// The number of outputs must match the number of inputs for the target function (polynomialFitting, in this case).
	inputs := #{
		pkg(main)
		fn(inputs)
	}

	// This function returns outputs to be matched against the outputs from the evolved function.
	// For example, we can return real stock market prices or we can return the result of a bot fighting against another bot.
	// The number of input parameters must match the number of inputs for the target function (polynomialFitting, in this case),
	/// which is the same number as the number of parameters for the `inputs` function above.
	// The number of outputs must match the number of outputs for the target function (polynomialFitting, in this case).
	outputs := #{
		pkg(main)
		fn(outputs)
	}

	// 
	eval := #{
		pkg(main)
		fn(eval)
	}

	str.print("Starting")

	// evolve.evolve performs the actual evolutionary process.
	// Arguments:
	// target - The target function to evolve
	// fnBag - The operators to use to create expressions
	// inps - The inputs the bots will be taking as... well, inputs
	// outs - The outputs the bot needs to generate
	// 10 - Each bot will have 10 expressions (for example, foo = 5 + 5 is one expression)
	// 10000 - The maximum number of iterations
	// 100 - The number of bots in the population. These bots are used for crossover
	// 0.1D - If the error gets below this error, then stop. No need to do 10,000 iterations if that's the case, although at the moment I usually stop the program with Ctrl-C Ctrl-C

	// var nums []i32
	// nums = inputs()
	// for c := 0; c < 3; c++ {
	// 	i32.print(nums[c])
	// }
	
	// evolve.evolve(target, fnBag, inputs, outputs, eval, 10, 10000, 100, 0.1D)
	
	evolve.evolve(target, fnBag, inputs, outputs, eval, 3, 10000, 100, 0.1D)

	str.print("ending")

	// Sometimes the algorithm finds a solution in the first iteration.
	// Sometimes the algorithm finds a solution in the first 10 iterations.
	// and... sometimes the alogorithm gets stuck, which is normal in evolutionary algorithms.
	// Later on we need to implement some simple mechanisms to avoid getting stuck in local minima.
}
