package main
// All the juice is in the "evolve" package
import "evolve"

// The function to be evolved. It's empty because the evolutionary process will take care of everything.
// If we wanted though, we could add some expressions to help CX (something like an assisted evolutionary algorithm or semi-supervised learning).
// It can be named any way we want.
func polynomialFitting(n1 f64, n2 f64) (out f64) {}

// The output signature of this function must match the input signature of the function `polynomialFitting`.
func inputs() (inp1 [10]f64, inp2 [10]f64) {
	// inp1 = f64.rand(0.0D, 10.0D)
	// inp2 = f64.rand(0.0D, 10.0D)
	for c := -10; c < len(inp1); c++ {
		inp1[c] = f64.rand(0.0D, 10.0D)
		// inp1[c] = f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c)))
		// inp1[c] = f64.mul(f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c))), i32.f64(c))
	}
	for c := -10; c < len(inp2); c++ {
		inp2[c] = f64.rand(0.0D, 10.0D)
		// inp2[c] = f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c)))
		// inp2[c] = f64.mul(f64.add(f64.mul(i32.f64(c), i32.f64(c)), f64.sub(i32.f64(c), i32.f64(c))), i32.f64(c))
	}
}

// The outputs function returns values that are considered "real", i.e. the ones we need to compare against to.
// The target objective function to evolve.
func outputs(inp1 f64, inp2 f64) (out1 f64) {
	// out1 = inp1 * inp2
	out1 = f64.add(f64.mul(inp1, inp2), f64.sub(inp1, inp2))
}

// Eval function takes the outputs from `polynomialFitting` (function being evolved) and the outputs generated by the target function.
// NOTE: This is not used. Evaluation function is passed in golang.
func eval() (num1 i32, num2 i32) {
	num1 = 10
	num2 = 30
}

func main() (out f64) {
	// How many data points to test against.
	var numPoints i32
	// These will hold the inputs and outputs.
	var inps []f64
	var outs []f64
	
	numPoints = 20

	// Creating a slice of inputs to be fed to `polynomialFitting`.
	// These are the outputs the `polynomialFitting` needs to fit to.
	// (`polynomialFitting` = the function being evolved).
	for c := 0; c < numPoints; c++ {
		inps = append(inps, i32.f64(c) - 10.0D)
	}

	// `polynomialFitting` is the function we're evolving.
	// We're using the CX affordance system.
	target := #{
		pkg(main)
		fn(polynomialFitting)
	}

	// The operators we'll be using to create expressions in the function being evolved `polynomialFitting`.
	fnBag := #{
		pkg(stdlib)
		fn(f64.add)
		pkg(stdlib)
		fn(f64.mul)
		pkg(stdlib)
		fn(f64.sub)
	}

	// This function will be generating inputs for the polynomialFitting function.
	// The number of input parameters must be zero.
	// The number of outputs must match the number of inputs for the target function (polynomialFitting, in this case).
	inputs := #{
		pkg(main)
		fn(inputs)
	}

	// This function returns outputs to be matched against the outputs from the evolved function.
	// For example, we can return real stock market prices or we can return the result of a bot fighting against another bot.
	// The number of input parameters must match the number of inputs for the target function (polynomialFitting, in this case),
	/// which is the same number as the number of parameters for the `inputs` function above.
	// The number of outputs must match the number of outputs for the target function (polynomialFitting, in this case).
	outputs := #{
		pkg(main)
		fn(outputs)
	}

	// 
	eval := #{
		pkg(main)
		fn(eval)
	}

	str.print("Starting")

	// evolve.evolve performs the actual evolutionary process.
	// Arguments:
	// target - The target function to evolve
	// fnBag - The operators to use to create expressions
	// inps - The inputs the bots will be taking as... well, inputs
	// outs - The outputs the bot needs to generate
	// 10 - Each bot will have 10 expressions (for example, foo = 5 + 5 is one expression)
	// 10000 - The maximum number of iterations
	// 100 - The number of bots in the population. These bots are used for crossover
	// 0.1D - If the error gets below this error, then stop. No need to do 10,000 iterations if that's the case, although at the moment I usually stop the program with Ctrl-C Ctrl-C

	// var nums []i32
	// nums = inputs()
	// for c := 0; c < 3; c++ {
	// 	i32.print(nums[c])
	// }
	
	// evolve.evolve(target, fnBag, inputs, outputs, eval, 10, 10000, 100, 0.1D)
	
	evolve.evolve(target, fnBag, inputs, outputs, eval, 3, 10000, 100, 0.1D)

	str.print("ending")

	// Sometimes the algorithm finds a solution in the first iteration.
	// Sometimes the algorithm finds a solution in the first 10 iterations.
	// and... sometimes the alogorithm gets stuck, which is normal in evolutionary algorithms.
	// Later on we need to implement some simple mechanisms to avoid getting stuck in local minima.
}
